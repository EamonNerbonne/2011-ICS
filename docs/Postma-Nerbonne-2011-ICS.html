<!DOCTYPE html>
<html lang="en-us">
<head>
    <title>Simulating the Unstable Rotation of a Book (Introduction to Computational Science 2011-2012)</title>
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700italic,400italic,700' rel='stylesheet' type='text/css' />
    <link rel="stylesheet" type="text/css" href="report-style.css" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>
<body>
    <div class="margincontainer">
        <article class="textcontainer" id="outer_root">
        <script type="math/tex">
        %for \newcommand
        </script>
            <header class="titlepage">
                <hgroup>
                    <h1>Simulating the Unstable Rotation of a Book </h1>
                    <h2>Introduction to Computational Science 2011-2012 </h2>
                    <!--<h3>Version 0.3</h3>-->
                </hgroup>
                <div class="authorsbox">
                    <div>Ivar Postma</div>
                    <div>Eamon Nerbonne</div>
                </div>
            </header>
            <nav>
                <h1>Contents </h1>
                <div class="generateTableOfContents"></div>
            </nav>
            <aside>
                <h1>Abstract</h1>
                <p>Physical experiments show that a book can stably rotate along its shortest and its longest axis. Rotation along the middle axis proves unstable. The rotation of such an object can be simulated in different ways. Here, we show two different approaches to rigid body simulation: a particle based simulation and a simulation based on the conservation of angular momentum. </p>
            </aside>
            <section id="section-introduction">
                <!-- Chapter 1 - Introduction -->
                <h1>Introduction </h1>
                <p>Many students consider classical mechanics to be somewhat difficult because it's not always very intuitive. For some students this can lead to frustration when studying for an exam and under stress they might be inclined to throw their classical mechanics book out the window.</p>
                <p>There are many different ways to throw your classical mechanics book out of your window. One of the more popular ways is to use it as a frisbee. When a book is thrown like a frisbee it starts rotating around the center of mass of the book. Students that live in one of the higher floors of an apartment building may notice that this rotation is <em>stable</em>: until the book hits the ground, its apparent axis of rotation does not change.</p>
                <p>Let us now consider a hard cover book (<a href="#fig-axes-definition">[ref]</a>). We can define three perpendicular axes. The first axis, <script type="math/tex">x</script> in the figure below, runs through the midpoint of the spine of the book.  The second axis, <script type="math/tex">y</script>, runs through the midpoint of the top.  The third axis, <script type="math/tex">z</script>, runs through the midpoint of the book's cover. </p>
                <figure id="fig-axes-definition">
                    <img src="include/rotationaxes.png" alt="A cubiod and its main rotational axis X, Y and Z" />
                    <figcaption>A cuboid with its three main axes.</figcaption>
                </figure>
                <p> When thrown as a frisbee, the book rotates along the <script type="math/tex">z</script> axis. This rotation is stable, as is the rotation around the <script type="math/tex">y</script> axis. However, if we throw a book so that it is rotating along the <script type="math/tex">x</script> axis, the rotation is unstable. In space, we can see this unstable rotation more clearly because without gravity linear motion can be eliminated. The video below (<a href="#fig-video-ISS">[ref]</a>) demonstrates an experiment done on the international space station.</p>
                <!-- The <figure>-tag is used below because the <video>-tag doesn't work properly -->
                <figure id="fig-video-ISS">
                    <iframe width="420" height="315" src="http://www.youtube.com/embed/GgVpOorcKqc"></iframe>
                    <figcaption>Video of an experiment in space demonstrating stable and unstable rotation <a href="#bib-video-ISS">[ref]</a>.</figcaption>
                </figure>
                
                <p>In this project we will simulate the rotation of a book so that it behaves naturally (as in <a href="#fig-video-ISS">[ref]</a>).  Since the goal of this project is to simulate the rotation, we will consider a system without external forces.  We will look at two different approaches. Firstly, we will simulate the book as a number of particles connected by springs.  Rotation, whether stable or not, will be an emergent phenomenon based on the interaction between the particles.  The second approach will model the book as a single rigid body in which rotation is explicitly simulated using angular momentum and the book's moment of inertia.</p>
            </section>
            
            <section>
                <h1>Euler method</h1>
                <p>To implement the simulation, we will define a number of ordinary differential equations (ODEs). These will be solved numerically.  Since Euler's method is the simplest method and computationally cheap, it was used to solve the equations arising from the models below. </p>
                <p>In Euler integration the value of a function is computed at discrete timesteps <script type="math/tex">t_{i}</script> where <script type="math/tex">t_{i+1} = t_{i} + \Delta t</script>. The value of a function at the next timestep is computed using a linear extrapolation from its current value and its derivative: </p>
                <script type="math/tex; mode=display">
 g(t_{i+1}) = g(t_{i}) + \dot{g}(t_{i}) \Delta t
                </script>
                <p>We will use the notation <script type="math/tex">\dot{g} \equiv \tfrac{dg}{dt}</script> and <script type="math/tex">\ddot{g} \equiv \tfrac{d^2g}{dt^2}</script> for the first and second time derivatives of a function, as usual in the physics community.</p>

                <p>At each time step, Euler integration introduces an error which is (at worst) proportional <script type="math/tex">\Delta t</script>.  Thus, for a fixed time interval (which requires more timesteps as <script type="math/tex">\Delta t</script> decreases), the overall error is at worst directly proportional to <script type="math/tex">\Delta t</script>.  However, even with a short time step, the error will grow and the calculated value will drift far away from the actual value.  To reduce the effect of this drift, it is in general useful to use a higher order numerical integration technique resulting in less error.  These (usually) come at the cost of a longer computation time and cannot eliminate the error. As this simulation is not computationally intensive, a CPU can compute very many timesteps in real time, so that even Euler integration is sufficiently accurate to make demonstration of the numerical errors impractical.  To highlight the difference between the models, a larger-than-necessary timestep was thus used.</p>
            </section>
            
            <section id="section-particle">
                <!-- Chapter 3 - Partcile Simulation -->
                <h1>Particle Simulation </h1>
                <p>In the particle simulation a number of particles is defined and their position <script type="math/tex">x</script> is tracked over time. The rate of change of the position is the velocity <script type="math/tex">v</script> of the particle.  The velocity of a particle is not necessarily constant, it may also change over time. The rate of change of the velocity is defined by the acceleration <script type="math/tex">a</script> of a particle. Or: </p>
                <script type="math/tex; mode=display">
                \begin{align*}
                    v(t) &= \dot{x}(t) \\
                    a(t) &= \dot{v}(t) = \ddot{x}(t) 
                \end{align*}
                </script>
                <p>To find the acceleration of a particle we can use Newton's second law. </p>
                <script type="math/tex; mode=display">F = m a</script>
                <p>Where necessary, we will use subscripts to differentiate between particles.  For example, <script type="math/tex">x_i</script> is the position of the <script type="math/tex">i</script>-th particle, <script type="math/tex">F_i</script> the force acting on particle <script type="math/tex">i</script>, and <script type="math/tex">F_{ij}</script> the force acting on particle <script type="math/tex">i</script> due to the spring connected to the <script type="math/tex">j</script>-th particle.</p>
                <!--<p>Since the masses of particles are generally constant, the acceleration can be calculated from the force applied to the particle.</p>-->
                
                <section>
                    <h1>Modeling the book</h1>
                    <p>To model an object with particles we must define a number of particles, their mass and how they interact with each other. For simplicity, the book is modeled by eight particles located at the eight corner points of a cuboid. Each particle has the same mass and an initial position that depends on the initial orientation of the book. The initial linear velocity of each particle is computed using the initial angular velocity of the book as a whole.  To ensure the book maintains its shape, virtual springs are added between each pair of particles.  This means that in total there are 28 springs.</p>
                    <p>The force on <script type="math/tex">i</script> by the spring to <script type="math/tex">j</script> is (by Hooke's law) directly proportional to the displacement from the equilibrium length but in opposite direction.  Accounting for the fact that the orientation of the spring depends on the position of the particles it is attached to, this can be expressed as follows:</p>
                    <script type="math/tex; mode=display"> 
                        \begin{align*}
                            F_{ij} & = -k \left(\|x_i - x_j\| - \mathbf{L}_{ij}\right)\frac{x_i - x_j}{\|x_i - x_j\|} \\
                                       & = -k \left(1 - \frac{\mathbf{L}_{ij}}{\|x_i - x_j\|}\right)(x_i - x_j)
                        \end{align*}
                    </script>
                    <p>Here, <script type="math/tex">k</script> is the the spring constant (defined to be identical for all springs) and <script type="math/tex">\mathbf{L}_{ij}</script> the equilibrium length of the spring between <script type="math/tex">i</script> and <script type="math/tex">j</script> (as determined using the book's shape at rest). The total force on a particle <script type="math/tex">i</script> is simply the sum of the individual forces acting on it.</p>
                    <p>Although this simple model works, the springs maintaining the book's shape have a tendency to vibrate.  Initially, the book's springs are in equilibrium and thus do not provide the necessary centripetal acceleration to maintain the book's shape.  As the rotation causes the particles to move further apart spring tensions rise.  When the time the outward motion is fully halted by the high spring tension, the spring tension does not cease but instead starts pulling the points closer together again.  This process repeats indefinitely, causing vibration.  By increasing the spring constant, the amount of distortion to the shape can be minimized; after all, with stiffer springs less displacement is necessary to provide the same centripetal acceleration.</p>
                    <p>The error caused by Euler integration in this model causes the system to vibrate more and more strongly as time progresses.  In effect, by simulating the rotating motion in a piecewise linear fashion, the counteracting pull of the springs comes a short moment after the extension caused by the rotation.  Thus, on average, each time step adds a small amount of potential energy to the springs.  Eventually, the system diverges.  Visually, the book "blows up".  By decreasing the spring constant, the amount of potential energy gained each time step is reduced thus delaying the moment of divergence.  The choice of spring constant thus represents a trade-off between maintaining the shape as much as possible or delaying divergence as much as possible.</p>
                </section>
                <section>
                    <h1>Normalization</h1>
                    <p>One way to avoid divergence due to energy gain is by normalization.  After all, the amount of energy in the system is easily computed, and should remain constant.  There are two sources of energy in the model: the elastic potential energy of the springs, and the kinetic energy of the moving particles.  The potential energy depends on the displacement <script type="math/tex">r_{ij} = \|x_i - x_j\| - L_{ij}</script> of each spring:  <script type="math/tex">\sum 0.5 k r_{ij}^2</script>.  The kinetic energy is <script type="math/tex">\sum 0.5 m v_i^2</script>. Since altering the amount of elastic potential energy stored in the spring is complicated, we chose instead to simply scale the velocity of all particles equally by constant <script type="math/tex">c</script>.  Then, for total known energy <script type="math/tex">E</script>:</p>
                    <script type="math/tex; mode=display">
                        \begin{align*}
                            E &= \sum_{i<j}\frac{1}{2} k r_{ij}^2 + \sum_i\frac{1}{2} m (c v_i)^2 \\
                            c &= \sqrt{\frac{2E - k \sum r_{ij}^2}{m \sum v_i^2}}
                        \end{align*}
                    </script>
                    <p>Similarly, after very long runs, the center of mass may start drifting.  The drift may be avoided by subtracting the mean position from all positions and the mean velocity from all velocities.</p>
                    <p>Normalization successfully avoids divergence.  However, the model nevertheless starts vibrating: the spings still need to provide sufficient centripetal acceleration, and this involves  the springs extending then retracting in oscillating fashion as described before.  Furthermore, the error caused by the short delay between extension and counteracting pull causes the system to gain potential energy as before &mdash; now, however, with a corresponding decrease in kinetic energy.  The net effect is that the book's rotation slows as more and more rotational kinetic energy is converted to the spring's vibration.</p>                   
                </section>
                <section>
                    <h1>Damping</h1>
                    <p>Spings can be prevented from oscillating by damping them: introducing frictional force proportional to the rate of change of the spring's displacement.  A single-spring system can be described as follows:</p>
                    <script type="math/tex; mode=display">
                    \ddot{r} + b\dot{r} + c r = 0
                    </script>
                    <p>This system corresponds to the springs we've defined when <script type="math/tex">b = 0, c = k/m</script>.  Such a system is critically damped (i.e. returns to rest as quickly as possible) when <script type="math/tex">b = 2\sqrt{c}</script> instead.  Assuming critical damping we then have: </p>
                    <script type="math/tex; mode=display">
                        \begin{align*}
                            \ddot{r} & = -2\sqrt{\frac{k}{m}}\dot{r} - \frac{k}{m}r \\
                            F_{ij} &= \left(-2 \sqrt{k m}(v_i - v_j)\cdot\frac{x_i - x_j}{\|x_i - x_j\|}  - k \left( \|x_i - x_j\| - \mathbf{L}_{ij}\right)\right)\frac{x_i - x_j}{\|x_i - x_j\|}
                        \end{align*}
                    </script>
                    <p>
                        Damping avoids the unwanted distortion of the books shape.  As the system gains energy by extending the springs "for free", damping also somewhat compensates for this by losing energy when they contract again.  However, although the system remains stable for much longer than without normalization, a damped system still eventually diverges.  The combination of damping and normalization is required to get a reasonable simulation indefinitely.
                    </p>
                    <p>Damping and normalization prevent divergence, but they do not prevent the actual errors from accumulating.  Due to the damping+normalization, the local error is low in the sense that for any given short period of time, the error introduced is small.  However, in the long run the book's orientation will still diverge from the true orientation.  For many purposes, this doesn't matter: the book's exact state is less important than its behavior.</p>
                    <p>  If global error is to be reduced, smaller timesteps and/or a more accurate numerical integration technique would help.  However, a more serious source of global error is likely due to the model error: modeling a book as a bunch of springs does not accurately describe how the book behaves.  More accurate simulation will not avoid inherent inaccuracies in the model.  A better model would take into account the fact that the book is a rigid object.</p>
                </section>
                
                <section>
                    <h1>Implementation</h1>
                    <p>In our implementation the visualization is separated from the calculation of the rotation. For visualization we will need the world coordinates of the corner points of the book. Since the particles are located at these corners we can directly used their positions for visualization. </p>
                    <p>In particle simulation we need to store the positions and the velocities in 3D space of all the particles. Both are stored in a 3 <script type="math/tex">\times</script> 8 matrix. The interacting forces are stored in an 8 <script type="math/tex">\times</script> 8 matrix. The implementation is written in C++, in which matrices are not standard. The Eigen library can be used for linear algebra <a href="#bib-eigen">[ref]</a>. This library provides useful data types, such as matrices and vectors, and useful operations on these data types, such as the dot product of two matrices.</p>
                    <p>At each time step the positions, the velocities and the interacting forces have to be computed. After calculating the new values, they can be normalized. </p>
                    <p>When the positions of the corner points are known, we can use OpenGL to visualize the book. In OpenGL a cuboid is rendered by specifying its eight sides. The position of the eight corner points of the book define where to draw each side of the book. To be able the distinguish between different sides of the book a texture is rendered on the front, spine and back of the book. </p>
                </section>
            </section>
            
            <section id="section-rigid">
                <!-- Chapter 4 - Rigid Simulation-->
                <h1>Rigid Simulation</h1>
                <p>In the video in the introduction, one may notice that the only property of the book that changes is its orientation. The orientation can be described with an orientation matrix <script type="math/tex">R</script>. The change in orientation is determined by the angular velocity <script type="math/tex">\omega</script> of the object. </p>
                <script type="math/tex; mode=display">
                    \dot{R}(t) = R(t) * \omega (t)
                </script>
                <p>To update the orientation of the object, we need the angular velocity. This angular velocity, together with the moment of inertia of the body <script type="math/tex">I</script>, can be used to calculate the angular momentum <script type="math/tex">L</script> of the body: </p>
                <script type="math/tex; mode=display">
                    L(t) = I(t) \omega (t)
                </script>
                <p>Because we do not consider external forces in our model the angular momentum is constant. This means the angular velocity can be calculated with the moment of inertia. </p>
                <p>The moment of inertia is the measure of an object's resistance to change in its orientation <script type="math/tex">R</script>. For a given orientation matrix the moment of inertia is defined as:</p>
                <script type="math/tex; mode=display">
                    I(t) = R(t) I_{body} R(t)^T
                </script>
                <p>where <script type="math/tex">I_{body}</script> is the so-called inertia tensor of the object. In general, the inertia tensor of an object is defined as:</p>
                <script type="math/tex; mode=display">
                    I_{body} =
                        \begin{bmatrix}
                            I_{xx} & I_{xy} & I_{xz} \\
	                        I_{yx} & I_{yy} & I_{yz} \\
	                        I_{zx} & I_{zy} & I_{zz}
                        \end{bmatrix}
                </script>
                <p>The inertia tensor for a cuboid is known. For a cuboid of mass <script type="math/tex">M</script> and dimensions <script type="math/tex">a \times b \times c</script> the inertia tensor is defined as:</p>
                <script type="math/tex; mode=display">
                    I_{body} = \frac{1}{12} 
                        \begin{bmatrix}
                            M(b^2 + c^2) & 0 & 0 \\
	                        0 & M(a^2 + c^2) & 0 \\
	                        0 & 0 & M(a^2 + b^2)
                        \end{bmatrix}
                </script>
                <p>This inertia tensor does not change during the simulation and thus it can be precomputed. </p>
                
                <section>
                    <h1>Modeling the book</h1>
                    <p>Without linear momentum the center of mass of the book is stationary. This center of mass is the origin in our coordinate system. The corner points of the book are defined by body coordinates. Together with the orientation of the body these body coordinates can be used to determine the world coordinates of the corner points. The body coordinates are also used to computer the moment of inertia of the body.</p>
                </section>
                
                <section>
                    <h1>Normalization</h1>
                    <p>Using Euler integration to numerically solve the ODEs here will produce an error which causes the orientation matrix to contain values that are slightly larger than they should be. Visually, the book will "grow". To correct for the errors the orientation should be normalized. This is done by singular value decomposition (SVD). </p>
                </section>
                
                <section>
                    <h1>Implementation</h1>
                    <p>The only thing we need to store is a 3 <script type="math/tex">\times</script> 3 matrix describing the orientation, another 3 <script type="math/tex">\times</script> 3 matrix for the moment of inertia and vector decribing the angular momentum. In each timestep we calculate the angular velocity and we update the orientation. The orientation can then be normalized with SVD using the Eigen library. From the orientation matrix, the world coordinates of the corner points are determined which are used to visualize the book. </p>
                </section>
                
                <section>
                    <h1>Quaternions</h1>
                    <p>Quaternions provide a convenient mathematical notation for representing orientations and rotations of objects in three dimensions. Expressing rotations as quaternions offers some advantages over a matrix notation. Concatenating rotations has a low computational cost and it's easier to extract the angle and axis of rotation. In our case, they're useful because normalization of quaternions is computationally much cheaper than normalization of the orientation matrix via SVD.</p>
                    <p>A quaternion <script type="math/tex">q</script> can be written as <script type="math/tex">w + x i + y j + z k</script> where <script type="math/tex">i^2 = j^2 = k^2 = ijk = -1</script>. </p>
                    <p>In quaternion notation the orientation is denoted as <script type="math/tex">q</script>. The change in orientation is now given by:</p>
                    <script type="math/tex; mode=display">
                    \dot{q}(t) = q(t) * \frac{1}{2} \omega (t)
                    </script>
                    <p>To calculate the moment of inertia we can't use the transpose of the orientation matrix. Instead the complex conjugate of the orientation quaternion is used:</p>
                    <script type="math/tex; mode=display">
                    I(t) = q(t) I_{body} \overline{q}(t)
                    </script>
                    <p>Quaternions are supported in the Eigen library thus the implementation of the rigid method using quaternions are very similar to the one using an orientation matrix. This orientation matrix is replaced by a quaternion and in the calculating of the new orientation we add a factor 0.5.</p>
                    <p>Normalization of quaternions is also supported by Eigen. This normalization is similar to the normalization of a vector. The four values <script type="math/tex">w, x, y</script> and <script type="math/tex">z</script> are simply divided by the magnitude of the quaternion:</p>
                    <script type="math/tex; mode=display">
                    ||q|| = \sqrt{w^2+x^2+y^2+z^2}
                    </script>
                </section>
            </section>
            
            <!--<section id="section-implementation">
                <h1>Implementation</h1>
                <p>In our implementation the visualization is separated from the calculation of the rotation. For visualization we will need the world coordinates of the corner points of the book. There are three methods to calculate these coordinates. </p>
                <p>The implementation is written in C++. The Eigen library is used for linear algebra <a href="#bib-eigen">[ref]</a>. The library provides useful data types, such as matrices and vectors, and useful operations on these data types, such as the dot product of two matrices.</p>
                
                
                <section>
                    <h1>Particle Simulation</h1>
                    <p>In particle simulation we need to store the positions and the velocities in 3D space of all the particles. Both are stored in a 3 <script type="math/tex">\times</script> 8 matrix. The interacting forces are stored in an 8 <script type="math/tex">\times</script> 8 matrix.</p>
                    <p>At each time step the positions, the velocities and the interacting forces have to be computed. </p>
                    <p>After calculating the new values they can be normalized. <i class="highlight">TODO: Little more text.</i></p>
                </section>
                
                <section>
                    <h1>Rigid Simulation</h1>
                    <p>In each time step <script type="math/tex">I^{-1}</script> is calculated from the current orientation and the static moment of inertia of the body. Using this <script type="math/tex">I^{-1}</script> the angular velocity at that time step is calculated. <i class="highlight">TODO: Little more text.</i></p>
                </section>
                
                <section>
                    <h1>Visualisation</h1>
                    <p>OpenGL is used for the visualization of the rotating book. In OpenGL a cuboid is rendered by specifying its eight sides. The position of the eight corner points of the book define where to draw each side of the book. To be able the distinguish between different sides of the book a texture is rendered on the front, spine and back of the book. </p>
                </section>
            </section>-->
            
            <section id="section-results">
                <h1>Results</h1>
                <p>The implementation shows the visualization of a rotating book. There are three different methods to calculate the position of the corner points of the book, a particle-based method, a rigid method with an orientation matrix and a rigid method with quaternions. The user can reset the visualization to a rotation around each of the three axis. Normalization can be turned on and off.</p>
                <section>
                    <h1>Particle Simulation</h1>
                    <p>The particle-based simulation produces a natural looking simulation of the rotation of a book. The rotation along the shortest and longest axis is stable. Rotation along the middle axis also appears to be stable, but this rotation is not robust. As soon as the rotation is only slightly dis-aligned with the axis it turns into an unstable rotation.</p>
                    <p>Damping is a necessary part of this particle simulation. </p>
                    <p>This simulation is sufficiently fast. <i class="highlight">TODO: Little more text.</i></p>
                </section>
                
                <section>
                    <h1>Rigid Simulation</h1>
                    <p>A rigid simulation where the orientation of the body is updated in each time step can be implemented in two different ways: using a 3 <script type="math/tex">\times</script> 3 orientation matrix and using quaternions. </p>
                    
                    <section>
                        <h1>Orientation Matrix</h1>
                        <p>The simulation using an orientation matrix also produces a natural looking result. </p>
                        <p>Without normalization the error produced by Euler integration adds up and the shape of the book starts to change noticeably after some time. Eventually, the error is so extreme that the simulation crashes. <i class="highlight">TODO: Little more text.</i> </p>
                    </section>
                    
                    <section>
                        <h1>Quaternions</h1>
                        <p>The simulation of the rotating book using the quaternion-based implementation appears to be visually the same as the orientation matrix method. However, this changes when normalization is turned off. </p>
                        <p>Like the implementation with the orientation matrix the shape of the book will eventually change when normalization is turned off. <i class="highlight">TODO: Little more text.</i> </p>
                    </section>
                </section>
            </section>
            
            <section id="section-discussion">
                <h1>Discussion</h1>
                <p>Normalization is necessary in a stable simulation because of small errors in the integration technique. However, it is not necessary to normalize the calculation in every time step. When to normalize depends on the size of the time step and on the integration method. </p>
                <p>Choosing a higher order numerical integration technique, such as fourth-order Runga-Kutta, will produce a smaller error in every time step but this is computationally more expensive. Since we need to normalize anyway, which will eliminate the error made, Euler integration is sufficient for this simulation. <i class="highlight">TODO: Check overlap with section on Euler.</i> </p>
                <p>The particle-based simulation and the rigid simulation produce similar results. So can we say which method is better. If we wish to quantify this we could look at the computational load of both methods. However, this would only yield in this particular case where we simulate a rotation cuboid. If we look at the more general problem of rotating objects, the particle-based method has an advantage over the rigid method. In the rigid method we use the definition of the moment of inertia of our object. This means that if the moment of inertia is unknown we have to compute it in advance. For complex shapes this proves to be difficult thus it will take longer to implement. For particle simulation we only need to place the particles and define their interacting forces which is easier. </p>
                <p>Rigid simulation does have the advantage that the shape of body is kept intact (apart from numerical errors). This behavior is what you would expect from a solid body. Particles move more freely which causes the shape of the object to change. </p>
            </section>
            
            <section id="section-conclusion">
                <h1>Conclusion</h1>
                <p>Simulation of the rotation of a book can be successfully implemented with both a particle-based method and rigid method. In both methods it is important to normalize the calculations because numerical integration techniques introduce errors which will eventually cause the simulation to "explode". Which implementation is more useful depends on the application. For simple objects such as cuboids the rigid method is easy to implement and performs well. For more difficult shapes the particle-based method proves to be easier to implement because it does not rely on the moment of inertia of the object to be computed.</p>
                <p><i class="highlight">TODO: Extend conclusion.</i></p>
            </section>
            <aside class="bibliography">
                <h1>References </h1>
                <ul>
                    <li id="bib-eigen">B. Jacob et al. <a href="http://eigen.tuxfamily.org/">Eigen</a>, February 2012. </li>
                    <li id="bib-video-ISS">D. Pettit. <a href="http://www.youtube.com/watch?v=GgVpOorcKqc">Solid Body Rotation</a>, February 2012. </li>
                </ul>
            </aside>
        </article>
    </div>
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
//    tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
    //, "HTML-CSS": { scale: 105 }
  });
    </script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="generateTOC.js"></script>
</body>
</html>
